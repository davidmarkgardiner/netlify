[{"content":"\u003ch1 id=\"pod-security-admission\"\u003ePod Security Admission\u003c/h1\u003e\n\u003chr\u003e\n\u003c!-- ## title: Pod Security Admission\nlayout: article\nkeywords: AKS, containers, kubernetes, security, Pod Security Admission\ndescription: The Kubernetes Pod Security Standards define different isolation levels for Pods. These standards let you define how you want to restrict the behavior of pods in a clear, consistent fashion. --\u003e\n\u003cp\u003e\u003ca href=\"https://kubernetes.io/docs/concepts/security/pod-security-admission/\"\u003epod-security-admission\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://kubernetes.io/docs/concepts/security/pod-security-standards/\"\u003epod-security-standards\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://kubernetes.io/docs/tasks/configure-pod-container/migrate-from-psp/\"\u003emigrate-from-psp\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"pod-security-admission-has-replaced-pod-security-policy-psp\"\u003ePod Security Admission has replaced Pod Security Policy (PSP)\u003c/h2\u003e\n\u003cp\u003ePSA implements the Pod Security Standards (PSS), a set of policies describing various security-related characteristics of workloads in a Kubernetes cluster. As of version 1.25, PSA is now a stable feature, and PSP has been completely removed.\u003c/p\u003e\n\u003ch2 id=\"pod-security-admission-1\"\u003ePod Security Admission\u003c/h2\u003e\n\u003cp\u003eThe Kubernetes Pod Security Standards define different isolation levels for Pods. These standards allow you to clearly and consistently define how to restrict the behavior of Pods.\u003c/p\u003e\n\u003cp\u003eKubernetes provides a built-in Pod Security admission controller to enforce the Pod Security Standards. Pod security restrictions are applied at the namespace level when creating Pods.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eenforce - Policy violations will cause the pod to be rejected.\naudit\t- Policy violations will trigger the addition of an audit annotation to the event recorded in the audit log, but are otherwise allowed.\nwarn\t- Policy violations will trigger a user-facing warning, but are otherwise allowed.\n\nPrivileged\t - Unrestricted policy, providing the widest possible level of permissions. This policy allows for known privilege escalations.\nBaseline\t - Minimally restrictive policy which prevents known privilege escalations. Allows the default (minimally specified) Pod configuration.\nRestricted\t - Heavily restricted policy, following current Pod hardening best practices\n\n# The per-mode level label indicates which policy level to apply for the mode.\n#\n# MODE must be one of `enforce`, `audit`, or `warn`.\n# LEVEL must be one of `privileged`, `baseline`, or `restricted`.\n\npod-security.kubernetes.io/\u0026lt;MODE\u0026gt;: \u0026lt;LEVEL\u0026gt;\n\n# Optional: per-mode version label that can be used to pin the policy to the\n# version that shipped with a given Kubernetes minor version (for example v1.26).\n#\n# MODE must be one of `enforce`, `audit`, or `warn`.\n# VERSION must be a valid Kubernetes minor version, or `latest`.\n\npod-security.kubernetes.io/\u0026lt;MODE\u0026gt;-version: \u0026lt;VERSION\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"pspyaml\"\u003ePSP.yaml\u003c/h2\u003e\n\u003cp\u003e(example only, this was previously recommended for use)\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eapiVersion: policy/v1beta1\nkind: PodSecurityPolicy\nmetadata:\n  name: recommended-psp\nspec:\n  allowedHostPaths:\n  - pathPrefix: /var/log\n    readOnly: false\n  privileged: false\n  allowPrivilegeEscalation: false\n  readOnlyRootFilesystem: true\n  allowedCSIDrivers:\n    - name: blob.csi.azure.com\n    - name: disk.csi.azure.com\n    - name: file.csi.azure.com\n  allowedCapabilities:\n  - AUDIT_WRITE\n  - CHOWN\n  - DAC_OVERRIDE\n  - FOWNER\n  - FSETID\n  - KILL\n  - SETGID\n  - SETUID\n  - SETPCAP\n  - NET_BIND_SERVICE\n  - SYS_CHROOT\n  - SETFCAP\n  volumes:\n  - configMap\n  - downwardAPI\n  - emptyDir\n  - persistentVolumeClaim\n  - secret\n  - projected\n  hostNetwork: false\n  hostIPC: false\n  hostPID: false\n  runAsUser:\n    rule: \u0026#39;MustRunAsNonRoot\u0026#39;\n  seLinux:\n    rule: \u0026#39;RunAsAny\u0026#39;\n  supplementalGroups:\n    rule: \u0026#39;MustRunAs\u0026#39;\n    ranges:\n    - min: 1\n      max: 65535\n  fsGroup:\n    rule: \u0026#39;MustRunAs\u0026#39;\n    ranges:\n    - min: 1\n      max: 65535\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"deploymentyaml-that-is-now-recommended-for-use\"\u003edeployment.yaml that is NOW recommended for use.\u003c/h2\u003e\n\u003cp\u003eThis is a Kubernetes Pod Security Admission configuration file for a container called \u0026ldquo;podinfod\u0026rdquo;. It specifies security settings such as not allowing privilege escalation, running as a non-root user, and dropping all capabilities.\u003c/p\u003e\n\u003cp\u003eThis security context:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePrevents privilege escalation by setting allowPrivilegeEscalation to false.\u003c/li\u003e\n\u003cli\u003ePrevents service account token mounting by setting to false.\u003c/li\u003e\n\u003cli\u003eDrops all Linux capabilities by setting capabilities to drop all.\u003c/li\u003e\n\u003cli\u003eMakes the root file system read-only by setting readOnlyRootFilesystem to true.\u003c/li\u003e\n\u003cli\u003eRuns the container as a non-root user by setting runAsNonRoot to true and runAsUser to a non-root user ID (in this example, 1000).\u003c/li\u003e\n\u003cli\u003eBlock pod containers from sharing the host process ID namespace and host IPC namespace in a Kubernetes cluster\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e        app.kubernetes.io/name: podinfo-kustomize\n    spec:\n      hostIPC: false\n      hostPID: false\n      securityContext:\n        seccompProfile:\n          type: RuntimeDefault\n      automountServiceAccountToken: false\n      containers:\n        - name: podinfod\n          image: poc-container-registry.ubs.net/cr-demo/stefanprodan/podinfo:6.1.2\n          securityContext:\n            allowPrivilegeEscalation: false\n            privileged: false\n            readOnlyRootFilesystem: true\n            runAsNonRoot: true\n            runAsUser: 1000\n            seccompProfile:\n              type: RuntimeDefault\n            capabilities:\n              drop:\n                - all\n          imagePullPolicy: IfNotPresent\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"how-to-comply-with-constraints\"\u003eHow to comply with constraints\u003c/h2\u003e\n\u003cp\u003eThe simplest way to comply is to set labels as per guidance here: \u003ca href=\"notion://www.notion.so/podsecuritystandards.html\"\u003epod-security-standards\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"am18-policys-to-be-enforced-as-deny-using-azure-policy\"\u003eAM18 policys to be enforced as DENY using azure Policy\u003c/h1\u003e\n\u003cp\u003eSome background and guidance is provided below.\u003c/p\u003e\n\u003ch3 id=\"readonlyrootfilesystem\"\u003ereadOnlyRootFilesystem\u003c/h3\u003e\n\u003cp\u003eTo keep a system secure, it\u0026rsquo;s important to prevent containers from writing to the root file system, which can lead to instability or compromise. Attackers can exploit this to gain elevated privileges and execute arbitrary code on the host machine. However, sometimes a container needs to write to the root file system, such as when it needs to access system-level configuration files or write logs. In these cases, proceed with caution and only allow it when necessary. It\u0026rsquo;s generally recommended to restrict container access to the root file system to minimize the risk of compromise.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e\ncontainers:\n- name: podinfod\n  image: poc-container-registry.ubs.net/cr-demo/stefanprodan/podinfo:6.1.2 # {\u0026#34;$imagepolicy\u0026#34;: \u0026#34;demo:podinfo-dev\u0026#34;}\n  securityContext:\n    readOnlyRootFilesystem: true\n  imagePullPolicy: IfNotPresent\n  ports:\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"seccompprofile\"\u003eseccompProfile\u003c/h3\u003e\n\u003cp\u003eWe use Seccomp to limit the system calls that containers can make, reducing their potential to perform harmful operations and minimizing the attack surface. Seccomp profiles must be set to an allowed value; both the Unconfined profile and the absence of a profile are prohibited.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eRestricted Fields\n\nspec.securityContext.seccompProfile.type\nspec.containers[*].securityContext.seccompProfile.type\nspec.initContainers[*].securityContext.seccompProfile.type\nspec.ephemeralContainers[*].securityContext.seccompProfile.type\nAllowed Values\n\nRuntimeDefault\nLocalhost\n\u003c/code\u003e\u003c/pre\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode\u003espec:\nsecurityContext:\n  # allowPrivilegeEscalation: false\n  # readOnlyRootFilesystem: true\n  # runAsNonRoot: true\n  # runAsUser: 1000\n  # capabilities:\n  #   drop:\n  #     - all\n  seccompProfile:\n    type: RuntimeDefault\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"automountserviceaccounttoken\"\u003eautomountServiceAccountToken\u003c/h3\u003e\n\u003cp\u003eIn AKS, pods may auto-mount a service token, which is used for authentication and authorization purposes. Service tokens are linked to a service account and are used by Kubernetes to grant permissions to resources in the cluster. AKS assigns a service account by default to each pod for authentication requests made to the Kubernetes API server.\u003c/p\u003e\n\u003cp\u003eThe service account associated with a pod is used to authenticate requests made by the pod to the Kubernetes API server and determine the level of authorization it has. To access certain resources, such as secrets or config maps, the pod needs to be authorized by the service account. By auto-mounting the service token, the pod can authenticate itself with the Kubernetes API server and access the necessary resources. This ensures that the pod functions properly and has the necessary permissions to perform its tasks.\u003c/p\u003e\n\u003cp\u003eAuto-mounting the service token is an important step in securing the cluster and ensuring that pods have the necessary authentication and authorization to access the resources they need. However, if not properly managed, it can also pose a security risk. An attacker who gains access to a pod with a mounted service account token can potentially use the token to authenticate and gain access to other resources within the cluster.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003espec:\nsecurityContext:\n  # allowPrivilegeEscalation: false\n  # readOnlyRootFilesystem: true\n  # runAsNonRoot: true\n  # runAsUser: 1000\n  # capabilities:\n  #   drop:\n  #     - all\n  # seccompProfile:\n  #   type: RuntimeDefault\nautomountServiceAccountToken: false\ncontainers:\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"allowprivilegeescalation\"\u003eallowPrivilegeEscalation\u003c/h3\u003e\n\u003cp\u003eWe prevent the creation of privileged containers in a Kubernetes cluster. Privileged containers run with root privileges and have access to all resources on the host machine, including the ability to modify system files and access sensitive data.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ePrivileged Pods disable most security mechanisms and must be disallowed.\n\nRestricted Fields\n\nspec.containers[*].securityContext.privileged\nspec.initContainers[*].securityContext.privileged\nspec.ephemeralContainers[*].securityContext.privileged\n\nAllowed Values\nUndefined/nil\nfalse\n\u003c/code\u003e\u003c/pre\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode\u003econtainers:\n- name: podinfod\n  image: poc-container-registry.ubs.net/cr-demo/stefanprodan/podinfo:6.1.2 # {\u0026#34;$imagepolicy\u0026#34;: \u0026#34;demo:podinfo-dev\u0026#34;}\n  securityContext:\n    allowPrivilegeEscalation: false\n    privileged: false\n    readOnlyRootFilesystem: true\n  imagePullPolicy: IfNotPresent\n  ports:\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"allowprivilegeescalation-1\"\u003eallowPrivilegeEscalation\u003c/h2\u003e\n\u003cp\u003eWe prevent privilege escalation in containers, where a process gains more privileges than originally granted. This is a serious security risk, as an attacker who gains control of a container with escalated privileges can potentially compromise the entire system.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ePrivilege escalation (such as via set-user-ID or set-group-ID file mode) should not be allowed.\nThis is Linux only policy in v1.25+\n\nRestricted Fields\n\nspec.containers[*].securityContext.allowPrivilegeEscalation\nspec.initContainers[*].securityContext.allowPrivilegeEscalation\nspec.ephemeralContainers[*].securityContext.allowPrivilegeEscalation\n\nAllowed Values\nfalse\n\u003c/code\u003e\u003c/pre\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode\u003econtainers:\n- name: podinfod\n  image: poc-container-registry.ubs.net/cr-demo/stefanprodan/podinfo:6.1.2 # {\u0026#34;$imagepolicy\u0026#34;: \u0026#34;demo:podinfo-dev\u0026#34;}\n  securityContext:\n    allowPrivilegeEscalation: false\n    privileged: false\n    readOnlyRootFilesystem: true\n  imagePullPolicy: IfNotPresent\n  ports:\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"hostipchostpid\"\u003eHostIPC/HostPID\u003c/h3\u003e\n\u003cp\u003eIn Kubernetes, containers are usually isolated from the host system\u0026rsquo;s processes and IPC namespaces. However, it\u0026rsquo;s possible to enable access to these namespaces by configuring the container\u0026rsquo;s Pod to use the host\u0026rsquo;s process and IPC namespaces. By setting the hostPID field in the Pod\u0026rsquo;s spec section to true, the container running in the Pod will have access to the host\u0026rsquo;s process namespace. This allows the container to interact with processes running on the host system. In addition, by setting the hostIPC field in the Pod\u0026rsquo;s spec section to true, the container running in the Pod will have access to the host\u0026rsquo;s IPC namespace. This enables the container to use shared memory, semaphores, and other interprocess communication mechanisms that are not available within the container\u0026rsquo;s own namespace. However, enabling access to the host\u0026rsquo;s process and IPC namespaces can be a security risk, as it may allow the container to interfere with other processes or containers running on the host system. Therefore, it\u0026rsquo;s generally recommended to avoid using these features unless absolutely necessary.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eSharing the host namespaces must be disallowed.\n\nRestricted Fields\n\nspec.hostNetwork\nspec.hostPID\nspec.hostIPC\n\nAllowed Values\nUndefined/nil\nfalse\n\u003c/code\u003e\u003c/pre\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e\napp.kubernetes.io/name: podinfo-kustomize\nspec:\n  hostIPC: false\n  hostPID: false\n  securityContext:\n    # allowPrivilegeEscalation: true\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"allowedvolumetypes\"\u003eAllowedVolumeTypes\u003c/h3\u003e\n\u003cp\u003eNot covered by pod security standards and must be set on the policy itself.\n\u003ca href=\"https://kubernetes.io/docs/tasks/configure-pod-container/migrate-from-psp/\"\u003ehttps://kubernetes.io/docs/tasks/configure-pod-container/migrate-from-psp/\u003c/a\u003e\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eThe restricted policy only permits the following volume types.\n\nRestricted Fields\n\nspec.volumes[*]\nAllowed Values\n\nEvery item in the spec.volumes[*] list must set one of the following fields to a non-null value:\n\nspec.volumes[*].configMap\nspec.volumes[*].csi\nspec.volumes[*].downwardAPI\nspec.volumes[*].emptyDir\nspec.volumes[*].ephemeral\nspec.volumes[*].persistentVolumeClaim\nspec.volumes[*].projected\nspec.volumes[*].secret\n\u003c/code\u003e\u003c/pre\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  containers:\n    - name: demo\n      image: alpine\n  volumes:\n  # You set volumes at the Pod level, then mount them into containers inside that Pod\n  - name: config\n    configMap:\n      # Provide the name of the ConfigMap you want to mount.\n      name: demo-name\n      # An array of keys from the ConfigMap to create as files\n      items:\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe recommended allowedVolumeTypes for Kubernetes depend on the specific requirements of your application and the level of security you want to enforce. However, there are some commonly used volume types that are generally considered safe to use in Kubernetes:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003econfigMap: Used to store configuration data as key-value pairs. ConfigMaps can be used to store data that is required by the container at runtime, such as environment variables, command-line arguments, and configuration files.\u003c/li\u003e\n\u003cli\u003eemptyDir: A temporary volume that is created when a Pod is launched and deleted when the Pod is terminated. This type of volume is useful for storing temporary data that is required by the container during its lifecycle.\u003c/li\u003e\n\u003cli\u003esecret: Used to store sensitive data, such as passwords, encryption keys, and API tokens. Secrets are encrypted at rest and can only be accessed by authorized users or applications.\u003c/li\u003e\n\u003cli\u003epersistentVolumeClaim: A claim to a persistent storage resource, such as a disk volume, that is managed by Kubernetes. This type of volume is useful for storing data that needs to persist beyond the lifetime of a Pod.\u003c/li\u003e\n\u003cli\u003edownwardAPI: Used to expose Pod and container metadata, such as labels, annotations, and environment variables, as files inside the container\u0026rsquo;s filesystem.\u003c/li\u003e\n\u003cli\u003eprojected: A flexible volume type that can be used to combine multiple volume sources into a single directory tree inside the container\u0026rsquo;s filesystem. The projected volume can include a mix of ConfigMaps, Secrets, and downwardAPI volumes.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSome volume types (e.g. hostPath, nfs, and glusterfs) give access to the host system\u0026rsquo;s filesystem or network, making them less secure. They should only be used when necessary and with caution. It\u0026rsquo;s best to evaluate the security requirements of your application and choose the appropriate volume types that provide necessary functionality without compromising security.\u003c/p\u003e\n\u003ch3 id=\"capabilities-system-admin\"\u003ecapabilities: system admin\u003c/h3\u003e\n\u003cp\u003eallowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This boolean directly controls whether the no_new_privs flag is set on the container process.\u003c/p\u003e\n\u003cp\u003eallowPrivilegeEscalation is always true when the container is run as privileged or has CAP_SYS_ADMIN.\u003c/p\u003e\n\u003cp\u003eThe duplication of this setting is governed by allowPrivilegeEscalation.\u003c/p\u003e\n\u003cp\u003eYou cannot set \u003ccode\u003eallowPrivilegeEscalation\u003c/code\u003e to false and \u003ccode\u003ecapabilities.Add\u003c/code\u003e CAP_SYS_ADMIN\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eAdding additional capabilities beyond those listed below must be disallowed.\n\nRestricted Fields\n\nspec.containers[*].securityContext.capabilities.add\nspec.initContainers[*].securityContext.capabilities.add\nspec.ephemeralContainers[*].securityContext.capabilities.add\n\nAllowed Values\n\nUndefined/nil\nAUDIT_WRITE\nCHOWN\nDAC_OVERRIDE\nFOWNER\nFSETID\nKILL\nMKNOD\nNET_BIND_SERVICE\nSETFCAP\nSETGID\nSETPCAP\nSETUID\nSYS_CHROOT\n\u003c/code\u003e\u003c/pre\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode\u003econtainers:\n  - name: podinfod\n    image: poc-container-registry.ubs.net/cr-demo/stefanprodan/podinfo:6.1.2\n    securityContext:\n      capabilities:\n        add: [\u0026#34;NET_ADMIN\u0026#34;, \u0026#34;SYS_TIME\u0026#34;]\n        drop: [\u0026#34;CAP_SYS_ADMIN\u0026#34;]\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"securitycontextsysctls\"\u003esecurityContext.sysctls\u003c/h3\u003e\n\u003cp\u003eYou can use the \u003ccode\u003esysctls\u003c/code\u003e field to specify a list of kernel parameters (sysctls) that are forbidden in the container. By default, all sysctls are allowed in the container unless they are explicitly forbidden using the \u003ccode\u003esysctls\u003c/code\u003e field.\u003c/p\u003e\n\u003cp\u003eHere are some examples of forbidden sysctl interfaces that you can specify:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eSysctls can disable security mechanisms or affect all containers on a host, and should be disallowed except for an allowed \u0026#34;safe\u0026#34; subset. A sysctl is considered safe if it is namespaced in the container or the Pod, and it is isolated from other Pods or processes on the same Node.\n\nRestricted Fields\n\nspec.securityContext.sysctls[*].name\n\nAllowed Values\nUndefined/nil\nkernel.shm_rmid_forced\nnet.ipv4.ip_local_port_range\nnet.ipv4.ip_unprivileged_port_start\nnet.ipv4.tcp_syncookies\nnet.ipv4.ping_group_range\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe following sysctls will be forbidden:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003enet.ipv4.ip_forward: This disables IP forwarding between network interfaces. It\u0026rsquo;s commonly used in denial-of-service attacks, so it\u0026rsquo;s generally a good idea to forbid it in most cases.\u003c/li\u003e\n\u003cli\u003enet.ipv4.conf.all.accept_source_route: This disables source routing, which allows a sender to specify the path that a packet should take through a network. Source routing can be used to bypass security measures, so it\u0026rsquo;s often forbidden in secure environments.\u003c/li\u003e\n\u003cli\u003ekernel.shm*: This forbids all shared memory kernel parameters, which can be used to control the behavior of shared memory segments in the container. These sysctls are often forbidden because they can be used to mount denial-of-service attacks.\u003c/li\u003e\n\u003cli\u003ekernel.sem: This disables POSIX message queues and semaphore operations. These operations can be used to synchronize access to shared resources, but they can also be used to mount denial-of-service attacks.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIt\u0026rsquo;s important to note that forbidding certain sysctl interfaces can break the functionality of certain applications or services that rely on these interfaces.\u003c/p\u003e\n\u003ch3 id=\"allowedhostpaths\"\u003eAllowedHostPaths\u003c/h3\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eHostPath volumes must be forbidden.\n\nRestricted Fields\n\nspec.volumes[*].hostPath\nAllowed Values\n\nUndefined/nil\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eKubernetes enables you to mount a host path as a volume in a container within a pod, which can be helpful in certain scenarios such as when you need to access files or data on the host system. However, this also creates a security risk as it could allow a container to access sensitive data or files on the host system.\u003c/p\u003e\n\u003cp\u003eTo mitigate this security risk, Kubernetes provides the hostPath volume type with a set of AllowedHostPaths fields. This allows you to specify a list of host paths that are permitted to be mounted as volumes in a pod. By default, the AllowedHostPaths field is empty, which means that host path volumes are not permitted.\u003c/p\u003e\n\u003cp\u003eSome potential allowed paths might be:\u003c/p\u003e\n\u003cp\u003efor \u003ccode\u003eubuntu\u003c/code\u003e and \u003ccode\u003emariner\u003c/code\u003e tls certs\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ehostPath: /etc/ssl/certs\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ehostPath: /etc/pki/tls/certs\u003c/code\u003e\u003c/p\u003e\n\u003ch3 id=\"allowedprocmounttype\"\u003eAllowedProcMountType\u003c/h3\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eThe default /proc masks are set up to reduce attack surface, and should be required.\n\nRestricted Fields\n\nspec.containers[*].securityContext.procMount\nspec.initContainers[*].securityContext.procMount\nspec.ephemeralContainers[*].securityContext.procMount\n\nAllowed Values\nUndefined/nil\nDefault\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIn Kubernetes, you can increase the security of your cluster by disabling certain proc mount types. The /proc filesystem allows processes to access information about the running system. However, attackers could use some of the information exposed by this filesystem to gain information about the host system or other containers running on the same node.\u003c/p\u003e\n\u003cp\u003eTo disable proc mount types in Kubernetes, update the Azure policy with the procMount field set to Unmasked. This prevents containers in your cluster from accessing the /proc/sys, /proc/sysrq-trigger, and /proc/latency_stats filesystems.\u003c/p\u003e\n\u003cp\u003eIn Kubernetes, there are three different procMountTypes to mount the /proc filesystem into a container:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eDefault: This is the default value for procMount and is used to mount /proc with the default options. This includes read-only access to most files in the filesystem, and write access to some files.\u003c/li\u003e\n\u003cli\u003eUnmasked: This value allows for more privileged access to the /proc filesystem, which can expose sensitive information about the host system or other containers running on the same node. In particular, it allows for write access to the /proc/sys, /proc/sysrq-trigger, and /proc/latency_stats files.\u003c/li\u003e\n\u003cli\u003eNone: This value disables the mounting of the /proc filesystem in the container. This can be used to improve the security of the container, but may impact the functionality of some applications or services that rely on the /proc filesystem.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eCarefully consider which procMountType to use for your containers based on their specific requirements and the security implications of each option. In general, the Default option is recommended unless there is a specific need for more privileged access to the /proc filesystem, and it\u0026rsquo;s best to avoid using the None option unless necessary.\u003c/p\u003e\n\u003ch3 id=\"apparmor\"\u003eappArmor\u003c/h3\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eOn supported hosts, the runtime/default AppArmor profile is applied by default. The baseline policy should prevent overriding or disabling the default AppArmor profile, or restrict overrides to an allowed set of profiles.\n\nRestricted Fields\n\nmetadata.annotations[\u0026#34;container.apparmor.security.beta.kubernetes.io/*\u0026#34;]\n\nAllowed Values\nUndefined/nil\nruntime/default\nlocalhost/*\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"selinux\"\u003eSELinux\u003c/h3\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eSetting the SELinux type is restricted, and setting a custom SELinux user or role option is forbidden.\n\nRestricted Fields\n\nspec.securityContext.seLinuxOptions.type\nspec.containers[*].securityContext.seLinuxOptions.type\nspec.initContainers[*].securityContext.seLinuxOptions.type\nspec.ephemeralContainers[*].securityContext.seLinuxOptions.type\n\nAllowed Values\n\nUndefined/\u0026#34;\u0026#34;\ncontainer_t\ncontainer_init_t\ncontainer_kvm_t\n\nRestricted Fields\n\nspec.securityContext.seLinuxOptions.user\nspec.containers[*].securityContext.seLinuxOptions.user\nspec.initContainers[*].securityContext.seLinuxOptions.user\nspec.ephemeralContainers[*].securityContext.seLinuxOptions.user\nspec.securityContext.seLinuxOptions.role\nspec.containers[*].securityContext.seLinuxOptions.role\nspec.initContainers[*].securityContext.seLinuxOptions.role\nspec.ephemeralContainers[*].securityContext.seLinuxOptions.role\n\nAllowed Values\nUndefined/\u0026#34;\u0026#34;\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"enforcecsidriver---azure\"\u003eEnforceCSIDriver - Azure\u003c/h3\u003e\n\u003cp\u003eKubernetes version 1.26 deprecates the in-tree persistent volume types \u003ca href=\"http://kubernetes.io/azure-disk\"\u003ekubernetes.io/azure-disk\u003c/a\u003e and \u003ca href=\"http://kubernetes.io/azure-file\"\u003ekubernetes.io/azure-file\u003c/a\u003e, which will no longer be supported. The corresponding CSI drivers \u003ca href=\"http://disks.csi.azure.com/\"\u003edisks.csi.azure.com\u003c/a\u003e and \u003ca href=\"http://file.csi.azure.com/\"\u003efile.csi.azure.com\u003c/a\u003e should be used instead. Although removing the deprecated drivers is not planned, you should migrate to the CSI drivers.\u003c/p\u003e\n\u003cp\u003eSome clusters still use the deprecated \u003ccode\u003eazureFile\u003c/code\u003e volume type, which has been deprecated since version 1.22. However, this type cannot be disabled without also disabling the \u003ccode\u003ekubernetes.io\u003c/code\u003e type. The policy is currently on/off and cannot be used flexibly yet. This policy is intended to help with the transition, not security. We recommend leaving it in audit mode only until after the 1.26 release, at which point we can move to deny mode. We will alert users on version 1.25 to migrate to version 1.26.\u003c/p\u003e\n\u003cp\u003eWe advise any team currently using the deprecated Kubernetes volume types to plan their migration immediately. The affected drivers that need to be migrated to \u003ccode\u003e*.csi.azure.com\u003c/code\u003e are \u003ccode\u003ekubernetes.io\u003c/code\u003e and \u003ccode\u003eazureFile\u003c/code\u003e.\u003c/p\u003e\n\u003ch3 id=\"allowedflexvolumes--flexvolumedriver\"\u003eAllowedFlexVolumes + FlexVolumeDriver\u003c/h3\u003e\n\u003cp\u003eIn Kubernetes, FlexVolume is a pluggable interface that allows third-party storage providers to create custom volume drivers for use in Kubernetes clusters. These drivers can be used to mount external storage systems or add functionality, such as encryption or compression, to Kubernetes volumes.\u003c/p\u003e\n\u003cp\u003eThe FlexVolume interface is designed to be flexible and extensible, and can be used with a wide range of storage systems, including cloud storage services, network-attached storage (NAS) devices, and local storage devices.\u003c/p\u003e\n\u003cp\u003eFlexVolume drivers are installed on the nodes in a Kubernetes cluster and are invoked by kubelet when a Pod requests a volume backed by the driver. The FlexVolume driver then communicates with the external storage system to create or mount the volume and provides Kubernetes with the necessary information to mount the volume in the Pod.\u003c/p\u003e\n","description":null,"image":"/images/docker.jpg","permalink":"https://davidmarkgardiner.com/blogs/pod-secutiry-admission/","title":"Pod Secutiry Admission"},{"content":"\u003c!-- # Pod Security Standards --\u003e\n\u003chr\u003e\n\u003cp\u003e\u003ca href=\"https://kubernetes.io/docs/concepts/security/pod-security-admission/\"\u003epod-security-admission\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://kubernetes.io/docs/concepts/security/pod-security-standards/\"\u003epod-security-standards\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://kubernetes.io/docs/tasks/configure-pod-container/migrate-from-psp/\"\u003emigrate-from-psp\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"pod-security-standards\"\u003ePod Security Standards\u003c/h2\u003e\n\u003cp\u003eThe Kubernetes Pod Security Standards define different isolation levels for Pods. These standards let you define how you want to restrict the behavior of pods in a clear, consistent fashion.\u003c/p\u003e\n\u003cp\u003eKubernetes offers a built-in Pod Security admission controller to enforce the Pod Security Standards. Pod security restrictions are applied at the namespace level when pods are created.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Privileged\nUnrestricted policy, providing the widest possible level of permissions. This policy allows for known privilege escalations.\n\n# Baseline\nMinimally restrictive policy which prevents known privilege escalations. Allows the default (minimally specified) Pod configuration.\n\n# Restricted\nHeavily restricted policy, following current Pod hardening best practices\n\u003c/code\u003e\u003c/pre\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# enforce\nPolicy violations will cause the pod to be rejected.\n\n# audit\nPolicy violations will trigger the addition of an audit annotation to the event recorded in the audit log, but are otherwise allowed.\n\n# warn\nPolicy violations will trigger a user-facing warning, but are otherwise allowed.\n\u003c/code\u003e\u003c/pre\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# The per-mode level label indicates which policy level to apply for the mode.\n#\n# MODE must be one of `enforce`, `audit`, or `warn`.\n# LEVEL must be one of `privileged`, `baseline`, or `restricted`.\n\npod-security.kubernetes.io/\u0026lt;MODE\u0026gt;: \u0026lt;LEVEL\u0026gt;\n\n# Optional: per-mode version label that can be used to pin the policy to the\n# version that shipped with a given Kubernetes minor version (for example v1.26).\n#\n# MODE must be one of `enforce`, `audit`, or `warn`.\n# VERSION must be a valid Kubernetes minor version, or `latest`.\n\npod-security.kubernetes.io/\u0026lt;MODE\u0026gt;-version: \u0026lt;VERSION\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eSetting labels  will allow you to enforce security pod policies that are also controlled via am18 (azurepolicy)\u003c/p\u003e\n\u003cp\u003elabels  \u003ccode\u003eenforce=baseline\u003c/code\u003e and \u003ccode\u003eenforce=resticted\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eI would advise using \u003ccode\u003erestricted\u003c/code\u003e where possible and \u003ccode\u003ebaseline\u003c/code\u003e as standard.\u003c/p\u003e\n\u003cp\u003efor production its recommended using audit for a week or more to check for any effected workloads\u003c/p\u003e\n\u003cp\u003elabels  \u003ccode\u003eaudit=baseline\u003c/code\u003e and \u003ccode\u003eaudit=resticted\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eFor detailed restrictions please see: \u003ca href=\"https://kubernetes.io/docs/concepts/security/pod-security-standards/\"\u003epod-security-standards\u003c/a\u003e\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eExample usage:\n``\n# Ensure to check warnings before enforcing this policy\n\nk label ns \u0026lt; namespace \u0026gt; pod-security.kubernetes.io/warn=baseline\nk label ns \u0026lt; namespace \u0026gt; pod-security.kubernetes.io/warn=restricted\n\n# We advise you to send logs to audit and monitor to check if anything is being blocked.\n\nk label ns \u0026lt; namespace \u0026gt; pod-security.kubernetes.io/audit=baseline\nk label ns \u0026lt; namespace \u0026gt; pod-security.kubernetes.io/audit=restricted\n\n# After you have remediated any warnings you can enforce settings.\n\nk label ns \u0026lt; namespace \u0026gt; pod-security.kubernetes.io/enforce=baseline\nk label ns \u0026lt; namespace \u0026gt; pod-security.kubernetes.io/enforce=restricted\n\u003c/code\u003e\u003c/pre\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Apply using script\n#!/bin/bash\n\n# Get a list of all namespaces in the cluster\nnamespaces=$(kubectl get namespaces -o jsonpath=\u0026#39;{range .items[*]}{.metadata.name}{\u0026#34;\\\\n\u0026#34;}{end}\u0026#39;)\n\n# Apply the label to each namespace\nfor namespace in $namespaces\ndo\n  kubectl label namespace $namespace pod-security.kubernetes.io/enforce=baseline\ndone\n\u003c/code\u003e\u003c/pre\u003e\u003c!-- ### How to comply with enforced Azure policy --\u003e\n\u003c!-- \nfor further guidance please see [pod-security-admission](notion://www.notion.so/podsecurityadmission.html)\n\n```\n\n# `pod-security.kubernetes.io/enforce=baseline`\n\nAKSAllowedProcMountType  | Pod containers can only use allowed ProcMountTypes in a Kubernetes cluster.\nAKSContainerDisSysA      | Limit pod HostPath volume mounts to the allowed host paths in a Kubernetes Cluster.\nAKSForSysInt             | Containers should not use forbidden sysctl interfaces in a Kubernetes cluster\nAKSContainerNP           | Do not allow privileged containers creation in a Kubernetes cluste\nAKSAppArmor              | Containers should only use allowed AppArmor profiles in a Kubernetes cluster.\nAKSAllowedHostPaths      | AKS Clusters should Limit pod HostPath volume mounts to the allowed host paths in Cluster\nAKSAllowedSeccompProfile | Pod containers can only use allowed seccomp profiles in a Kubernetes cluster\nAKSNoShHostProcHIPC      | Block pod containers from sharing the host process ID namespace and host IPC namespace in a Kubernetes cluster\n\n# `pod-security.kubernetes.io/enforce=restricted`\n\nAKSContainerNPEsc        | Do not allow containers to run with privilege escalation to root in a Kubernetes cluster\nAKSAllowedVolumeTypes    | Pods can only use allowed volume types in a Kubernetes cluster.\nAKSRORootFiles           | Run containers with a read only root file system to protect from changes at run-time with malicious binaries being added to PATH in a Kubernetes cluster\n\n```\n\n### Additional policys that will be set using label that are NOT currently enforced using azure policy\n\n```\n# Baseline\nKubernetes cluster containers should only use allowed capabilities\n  - Adding additional capabilities beyond those listed below must be disallowed.\n\nKubernetes cluster services should listen only on allowed ports\n  - HostPorts should be disallowed entirely (recommended) or restricted to a known list\n\nKubernetes cluster pods and containers should only use allowed SELinux options\n  - Setting the SELinux type is restricted, and setting a custom SELinux user or role option is forbidden.\n\n# Resticted\nKubernetes cluster pods and containers should only run with approved user and group IDs\n  - Containers must not set runAsUser to 0\n\n``` --\u003e\n","description":null,"image":"/images/desk.jpg","permalink":"https://davidmarkgardiner.com/blogs/pod-security-standards/","title":"Pod Security Standards"},{"content":"\u003cp\u003eabout me!\u003c/p\u003e\n","description":null,"image":null,"permalink":"https://davidmarkgardiner.com/about/","title":"About"}]